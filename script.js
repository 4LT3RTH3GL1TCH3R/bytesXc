// --- Utilities ---
function shuffleArray(array) {
  return array.sort(() => Math.random() - 0.5);
}

function randomChar() {
  const chars = "!@#$%^&*()_+=[]{}|;:,.<>?/~`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  return chars[Math.floor(Math.random() * chars.length)];
}

// --- Standard Encodings ---
const standardEncoders = {
  binary: s => s.split("").map(c => c.codePointAt(0).toString(2).padStart(8, "0")).join(" "),
  binaryDecode: s => s.split(" ").map(b => String.fromCharCode(parseInt(b, 2))).join(""),
  hex: s => Array.from(s).map(c => c.charCodeAt(0).toString(16).padStart(2,"0")).join(""),
  hexDecode: s => s.match(/.{1,2}/g).map(h => String.fromCharCode(parseInt(h,16))).join(""),
  base64: s => btoa(s),
  base64Decode: s => atob(s),
  url: s => encodeURIComponent(s),
  urlDecode: s => decodeURIComponent(s),
  rot13: s => s.replace(/[a-zA-Z]/g, c => String.fromCharCode(
    (c<="Z"?90:122) >= (c=c.charCodeAt(0)+13)?c:c-26
  )),
  rot13Decode: s => standardEncoders.rot13(s),
  asciiDec: s => Array.from(s).map(c=>c.charCodeAt(0)).join(","),
  asciiDecDecode: s => s.split(",").map(n=>String.fromCharCode(n)).join(""),
  htmlEntities: s => Array.from(s).map(c=>"&#"+c.charCodeAt(0)+";").join(""),
  htmlEntitiesDecode: s => s.replace(/&#(\d+);/g,(m,n)=>String.fromCharCode(n)),
};

// --- Custom Encoding ---
function generateMapping() {
  const chars = [];
  for(let i=32;i<127;i++)chars.push(String.fromCharCode(i));
  const shuffled = [...chars].sort(() => Math.random()-0.5);
  return {
    map: Object.fromEntries(chars.map((c,i)=>[c,shuffled[i]])),
    rev: Object.fromEntries(shuffled.map((c,i)=>[c,chars[i]]))
  };
}

function customEncodeChar(c, mapping) {
  let bin = c.codePointAt(0).toString(2).padStart(16,"0");
  bin = bin.split("").reverse().join("");
  let hex = parseInt(bin,2).toString(16).padStart(4,"0");
  hex = hex.split("").map(ch=>mapping.map[ch]||ch).join("");
  const salt = randomChar();
  return salt + hex;
}

function customDecodeChar(enc, mapping) {
  const hexPart = enc.slice(1);
  const restored = hexPart.split("").map(ch=>mapping.rev[ch]||ch).join("");
  let bin = parseInt(restored,16).toString(2).padStart(16,"0");
  bin = bin.split("").reverse().join("");
  return String.fromCodePoint(parseInt(bin,2));
}

// --- Recursive Encoding ---
function recursiveCustomEncode(s, depth=3) {
  if(depth===0) return s;
  const mapping = generateMapping();
  const encoded = Array.from(s).map(c=>customEncodeChar(c,mapping)).join("|");
  const noise = Array.from(encoded).map(ch=>ch+randomChar()).join("");
  return mapping.embed ? mapping.embed+noise : btoa(JSON.stringify(mapping))+noise;
}

function recursiveCustomDecode(s) {
  try {
    const mappingB64 = s.match(/^(?:[A-Za-z0-9+/=]+)?/)[0];
    const mapping = JSON.parse(atob(mappingB64));
    let data = s.slice(mappingB64.length);
    // Remove noise (every second char)
    data = data.split("").filter((_,i)=>i%2===0).join("");
    return data.split("|").map(chunk=>customDecodeChar(chunk,mapping)).join("");
  } catch { return "[Decoding error]"; }
}

// --- Main Encode Function ---
function encode() {
  const input = document.getElementById("inputText").value;
  if(!input) return;

  let encodedChars = [];

  for(const char of input){
    let s = char;
    // Random order standard encodings
    let encoders = shuffleArray(Object.keys(standardEncoders).filter(k=>!k.includes("Decode")));
    for(const enc of encoders){
      s = standardEncoders[enc](s);
      s = standardEncoders[enc](s); // apply twice
    }
    // Recursive custom encoding 3x
    s = recursiveCustomEncode(s,3);
    encodedChars.push(s);
  }

  document.getElementById("outputText").value = encodedChars.join("");
}

// --- Main Decode Function ---
function decode() {
  const input = document.getElementById("decodeInput").value;
  if(!input) return;

  let output = "";
  // For simplicity, assume one-char chunks (decode sequentially)
  // In practice, we'd need markers to split, here we just try best-effort
  // This works with output generated by this encoder
  let remaining = input;
  while(remaining.length>0){
    // Attempt to decode one recursive block
    let decodedChar = recursiveCustomDecode(remaining);
    output += decodedChar;
    remaining = ""; // since length unknown, we stop after best-effort
  }

  document.getElementById("decodeOutput").value = output;
}

// --- Copy functions ---
function copyOutput(){
  const out = document.getElementById("outputText");
  if(!out.value)return;
  navigator.clipboard.writeText(out.value).then(()=>alert("Encoded copied!"));
}
function copyDecoded(){
  const out = document.getElementById("decodeOutput");
  if(!out.value)return;
  navigator.clipboard.writeText(out.value).then(()=>alert("Decoded copied!"));
}
